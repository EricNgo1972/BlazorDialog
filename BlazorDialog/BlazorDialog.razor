@typeparam TInput
@inject DialogStates states
@inject IBlazorDialogService dialogService
@inherits BlazorDialogBase
@implements IDisposable

@if (Id != null && states.IsShowing.ContainsKey(Id) && states.IsShowing[Id])
{
    if (!IsCustom)
    {
        <div class="blazor-dialog-container @(Centered ? "blazor-dialog-centered" : "")">
            <div class="blazor-dialog-content-wrapper @ContentWrapperCssClass">
                <div class="blazor-dialog-content">
                    @ChildContent(new DialogContext<TInput>(this.Id, dialogService, (TInput)states.Inputs[Id]))
                </div>
            </div>
        </div>
    }
    else
    {
        @ChildContent(new DialogContext<TInput>(this.Id, dialogService, (TInput)states.Inputs[Id]))
    }
}

@code{
    [Parameter] protected RenderFragment<DialogContext<TInput>> ChildContent { get; set; }
    [Parameter] protected DialogSizes Size { get; set; } = DialogSizes.Normal;
    [Parameter] protected bool Centered { get; set; }
    [Parameter] protected bool IsCustom { get; set; }
    [Parameter] protected EventCallback OnShow { get; set; }
    [Parameter] protected EventCallback OnHide { get; set; }
    [Parameter] protected bool? IsShowing { get; set; }

    protected override void OnInit()
    {
        if (Id == null) throw new ArgumentNullException(nameof(Id));
        states.OnDialogStateChange += async () =>
        {
            if (states.IsShowing.ContainsKey(Id) && states.IsShowing[Id])
            {
                await OnShow.InvokeAsync(null);
            }
            else
            {
                await OnHide.InvokeAsync(null);
            }

            StateHasChanged();
        };
    }

    protected override void OnParametersSet()
    {
        if(IsShowing.HasValue && IsShowing.Value && (!states.IsShowing.ContainsKey(Id) || !states.IsShowing[Id]))
        {
            states.ShowDialog(this.Id, null);
        }
        else if (IsShowing.HasValue && !IsShowing.Value && states.IsShowing.ContainsKey(Id) && states.IsShowing[Id])
        {
            states.HideDialog(this.Id, null);
        }
    }

    public void Dispose()
    {
        if (states != null)
        {
            states.OnDialogStateChange -= StateHasChanged;
        }
    }

    private string ContentWrapperCssClass
    {
        get
        {
            switch (Size)
            {
                case DialogSizes.Normal:
                    return "";
                case DialogSizes.Small:
                    return "blazor-dialog-content-wrapper-small";
                case DialogSizes.Large:
                    return "blazor-dialog-content-wrapper-large";
                case DialogSizes.ExtraLarge:
                    return "blazor-dialog-content-wrapper-xlarge";
                default:
                    throw new Exception("Unknown dialog size");
            }
        }
    }

    public Task Show()
    {
        return dialogService.ShowDialog(this.Id);
    }

    public Task Show(TInput input)
    {
        return dialogService.ShowDialog<TInput>(this.Id, input);
    }

    public void Hide<TResult>(TResult result)
    {
        dialogService.HideDialog(this.Id, result);
    }

    public void Hide()
    {
        dialogService.HideDialog(this.Id);
    }
}